name: "Texinfo"
scopeName: "text.texinfo"
fileTypes: [
	"texinfo"
	"texi"
	"txi"
]
firstLineMatch: """(?x)
	# TeX directive
	^\\s*\\\\input\\s+texinfo\\s*$
	|
	# Modeline
	(?i:
		# Emacs
		-\\*-(?:\\s*(?=[^:;\\s]+\\s*-\\*-)|(?:.*?[;\\s]|(?<=-\\*-))mode\\s*:\\s*)
			texinfo
		(?=[\\s;]|(?<![-*])-\\*-).*?-\\*-
		
		|
		
		# Vim
		(?:(?:\\s|^)vi(?:m[<=>]?\\d+|m)?|\\sex)(?=:(?=\\s*set?\\s[^\\r\\n:]+:)|:(?!\\s* set?\\s))(?:(?:\\s|\\s*:\\s*)\\w*(?:\\s*=(?:[^\\r\\n\\\\\\s]|\\\\.)*)?)*[\\s:](?:filetype|ft|syntax)\\s*=
			texinfo
		(?=\\s|:|$)
	)
"""
injectionSelector: "emacs.lisp"
patterns: [{
	# \input texinfo.tex
	match: "\\A\\s*((\\\\)input)\\s+([^@\\s\\x7F]+)"
	captures:
		1: name: "support.function.general.tex"
		2: name: "punctuation.definition.function.tex"
		3: name: "support.constant.language.other.tex"
}, include: "#main"]

repository:
	main:
		patterns: [
			{include: "#comments"}
			{include: "#dashes"}
			{include: "#texLine"}
			{include: "#alias"}
			{include: "#booleanCommands"}
			{include: "#symbolCommands"}
			{include: "#quotation"}
			{include: "#verbatim"}
			{include: "#codeBlocks"}
			{include: "#conditionals"}
			{include: "#blockCommands"}
			{include: "#rawTex"}
			{include: "#rawHTML"}
			{include: "#rawXML"}
			{include: "#command"}
		]
	
	
	# @alias [new]=[existing]
	alias:
		name: "meta.command.alias.texinfo"
		match: "((@)alias)\\s+([^=\\s]+)\\s*(=)\\s*([^=\\s]+)"
		captures:
			1: name: "keyword.operator.command.alias.texinfo"
			2: name: "punctuation.definition.function.texinfo"
			3: name: "entity.name.function.alias.texinfo"
			4: name: "punctuation.separator.separator.texinfo"
			5: name: "entity.name.function.source.texinfo"
	
	
	# Block-type commands
	blockCommands:
		name:  "meta.command.$3.block.texinfo"
		begin: """(?x) ((@)
			(cartouche|copying|direntry|display|documentdescription|enumerate
			|float|flushleft|flushright|format|ftable|group|itemize|multitable
			|raggedright|smalldisplay|smallformat|smallindentedblock|table
			|titlepage|vtable))
			(?=\\s|$)
		"""
		end: "((@)end\\s+\\3)\\b"
		beginCaptures:
			1: name: "keyword.operator.command.$3.texinfo"
			2: name: "punctuation.definition.function.texinfo"
		endCaptures:
			1: name: "keyword.operator.command.end-$3.texinfo"
			2: name: "punctuation.definition.function.texinfo"
		patterns: [include: "#main"]
	
	
	# Commands which take boolean-like values as their only argument
	booleanCommands:
		patterns: [{
			# [on|off|single|double]
			name: "meta.command.headings.texinfo"
			match: "((@)headings)\\s+(?:(on)|(off)|(single|double))\\b"
			captures:
				1: name: "keyword.operator.command.headings.texinfo"
				2: name: "punctuation.defining.function.texinfo"
				3: name: "constant.language.boolean.true.texinfo"
				4: name: "constant.language.boolean.false.texinfo"
				5: name: "constant.language.heading-type.$5.texinfo"
		},{
			# [on|off|odd]
			name: "meta.command.setchapternewpage.texinfo"
			match: "((@)setchapternewpage)\\s+(?:(on)|(off)|(odd))\\b"
			captures:
				1: name: "keyword.operator.command.headings.texinfo"
				2: name: "punctuation.defining.function.texinfo"
				3: name: "constant.language.boolean.true.texinfo"
				4: name: "constant.language.boolean.false.texinfo"
				5: name: "constant.language.odd.texinfo"
		},{
			# [true|false]
			name: "meta.command.$3.texinfo"
			match: "((@)(allowcodebreaks))\\s+(true|false)(?=\\s|$)"
			captures:
				1: name: "keyword.operator.command.$3.texinfo"
				2: name: "punctuation.definition.function.texinfo"
				4: name: "constant.language.boolean.$4.texinfo"
		},{
			# [on|off]
			name: "meta.command.$3.texinfo"
			match: """(?x) ((@)
				(codequotebacktick|codequoteundirected|deftypefnnewline
				|frenchspacing|validatemenus|xrefautomaticsectiontitle))
				\\s+ (?:(on)|(off)) \\b
			"""
			captures:
				1: name: "keyword.operator.command.$3.texinfo"
				2: name: "punctuation.definition.function.texinfo"
				4: name: "constant.language.boolean.true.texinfo"
				5: name: "constant.language.boolean.false.texinfo"
		}]
	
	
	# Code examples
	codeBlocks:
		patterns: [{
			# Lisp code
			name: "meta.command.$3.block.texinfo"
			begin: "((@)(lisp|smalllisp))(?=\\s|$)"
			end:   "((@)end\\s+\\3)\\b"
			beginCaptures:
				1: name: "keyword.operator.command.$3.texinfo"
				2: name: "punctuation.definition.function.texinfo"
			endCaptures:
				1: name: "keyword.operator.command.end-$3.texinfo"
				2: name: "punctuation.definition.function.texinfo"
			contentName: "source.embedded.emacs.lisp"
			patterns: [
				{include: "source.emacs.lisp"}
				{include: "#main"}
			]
		},{
			name: "meta.command.$3.block.texinfo"
			begin: "((@)(example|smallexample|verbatim))(?=\\s|$)"
			end:   "((@)end\\s+\\3)\\b"
			beginCaptures:
				1: name: "keyword.operator.command.$3.texinfo"
				2: name: "punctuation.definition.function.texinfo"
			endCaptures:
				1: name: "keyword.operator.command.end-$3.texinfo"
				2: name: "punctuation.definition.function.texinfo"
			contentName: "markup.raw.texinfo"
			patterns: [include: "#main"]
		}]
	
	
	# Control flow
	conditionals:
		patterns: [{
			# Conditionals which take arguments
			name:  "meta.command.$3.conditional.block.texinfo"
			begin: "((@)(ifclear|ifcommanddefined|ifcommandnotdefined|ifset))\\s+(\\S+)"
			end:   "((@)end\\s+\\3)\\b"
			beginCaptures:
				1: name: "keyword.control.command.$3.texinfo"
				2: name: "punctuation.definition.function.texinfo"
				4: name: "variable.parameter.texinfo"
			endCaptures:
				1: name: "keyword.control.command.end-$3.texinfo"
				2: name: "punctuation.definition.function.texinfo"
			patterns: [include: "#main"]
		},{
			# Conditionals which don't
			name: "meta.command.$3.conditional.block.texinfo"
			begin: """(?x) ((@)
				(ifdocbook|ifhtml|ifinfo|ifnotdocbook|ifnothtml|ifnotinfo|ifnotplaintext
				|ifnottex|ifnotxml|ifplaintext|iftex|ifxml))
				(?=\\s|$)
			"""
			end:   "((@)end\\s+\\3)\\b"
			beginCaptures:
				1: name: "keyword.control.command.$3.texinfo"
				2: name: "punctuation.definition.function.texinfo"
				4: name: "variable.parameter.texinfo"
			endCaptures:
				1: name: "keyword.control.command.end-$3.texinfo"
				2: name: "punctuation.definition.function.texinfo"
			patterns: [include: "#main"]
		}]
	
	
	# Argument delimiter used in some contexts
	comma:
		name: "punctuation.separator.delimiter.comma.texinfo"
		match: ","
	
	
	# Generic command invocation
	command:
		patterns: [{
			# `@command{args}`
			name:  "meta.command.braced.texinfo"
			begin: "((@)(\\w+))({)"
			end:   "}"
			beginCaptures:
				1: name: "keyword.operator.command.$3.texinfo"
				2: name: "punctuation.definition.function.texinfo"
				4: name: "punctuation.section.scope.begin.texinfo"
			endCaptures:
				0: name: "punctuation.section.scope.end.texinfo"
			patterns: [
				name: "variable.parameter.texinfo"
				match: "[^\\s{}@,]+"
				
				{include: "#comma"}
				{include: "#main"}
			]
		},{
			# `@command`
			name: "keyword.operator.command.$2.texinfo"
			match: "(@)(\\w+)"
			captures:
				1: name: "punctuation.definition.function.texinfo"
		}]
	
	
	# Comment lines
	comments:
		patterns: [{
			# `@command` invocation
			name: "comment.line.at-sign.texinfo"
			begin: "((@)c(?:omment)?)(?=$|[^-A-Za-z0-9])"
			end:   "$"
			beginCaptures:
				1: name: "keyword.operator.command.start-comment.texinfo"
				2: name: "punctuation.definition.function.texinfo"
		},{
			# TeX-style comment
			name: "comment.line.tex-style.texinfo"
			begin: "\\x7F"
			end:   "$"
			beginCaptures:
				0: name: "punctuation.whitespace.delete.texinfo"
		}]
	
	
	# Em/en dashes
	dashes:
		patterns: [
			{match: "---", name: "constant.character.dash.em-dash.texinfo"}
			{match: "--",  name: "constant.character.dash.en-dash.texinfo"}
		]


	# Quote blocks
	quotation:
		name: "meta.command.$3.block.texinfo"
		begin: "((@)(quotation|smallquotation))(?=\\s|$)"
		end:   "((@)end\\s+\\3)\\b"
		beginCaptures:
			1: name: "keyword.operator.command.$3.texinfo"
			2: name: "punctuation.definition.function.texinfo"
		endCaptures:
			1: name: "keyword.operator.command.end-$3.texinfo"
			2: name: "punctuation.definition.function.texinfo"
		contentName: "markup.quote.texinfo"
		patterns: [include: "#main"]


	# `@html` … `@end html`
	rawHTML:
		name:  "meta.command.raw-html.block.texinfo"
		begin: "((@)html)(?=\\s|$)"
		end:   "((@)end\\s+html)\\b"
		beginCaptures:
			1: name: "keyword.operator.command.html.texinfo"
			2: name: "punctuation.definition.function.texinfo"
		endCaptures:
			1: name: "keyword.operator.command.end-html.texinfo"
			2: name: "punctuation.definition.function.texinfo"
		contentName: "source.embedded.html"
		patterns: [
			{include: "#main"}
			{include: "text.html.basic"}
		]


	# `@tex` … `@end tex`
	rawTex:
		name:  "meta.command.raw-tex.block.texinfo"
		begin: "((@)tex)(?=\\s|$)"
		end:   "((@)end\\s+tex)\\b"
		beginCaptures:
			1: name: "keyword.operator.command.tex.texinfo"
			2: name: "punctuation.definition.function.texinfo"
		endCaptures:
			1: name: "keyword.operator.command.end-tex.texinfo"
			2: name: "punctuation.definition.function.texinfo"
		contentName: "source.embedded.tex"
		patterns: [
			{include: "#main"}
			{include: "text.tex.latex"}
		]
	
	
	# `@xml`…`@end xml` / `@docbook …`@end docbook`
	rawXML:
		name:  "meta.command.raw-$3.block.texinfo"
		begin: "((@)(docbook|xml))(?=\\s|$)"
		end:   "((@)end\\s+\\3)\\b"
		beginCaptures:
			1: name: "keyword.operator.command.$3.texinfo"
			2: name: "punctuation.definition.function.texinfo"
		endCaptures:
			1: name: "keyword.operator.command.end-$3.texinfo"
			2: name: "punctuation.definition.function.texinfo"
		contentName: "source.embedded.xml"
		patterns: [
			{include: "#main"}
			{include: "text.xml"}
		]


	# Non-alphabetic commands
	symbolCommands:
		patterns: [{
			name: "keyword.operator.command.non-alphabetic.texinfo"
			match: "(@)[-!\"'&*./:=?@\\\\^`{}~]"
			captures:
				1: name: "punctuation.definition.function.texinfo"
		},{
			# “Escaped” whitespace
			name: "keyword.operator.command.whitespace.texinfo"
			match: "(@)(?:( |\\t)|$)"
			captures:
				1: name: "punctuation.definition.function.texinfo"
		},{
			# @, - Generate cedilla accent
			name: "meta.command.braced.texinfo"
			begin: "((@),)({)"
			end:   "}"
			beginCaptures:
				1: name: "keyword.operator.command.cedilla-accent.texinfo"
				2: name: "punctuation.definition.function.texinfo"
				3: name: "punctuation.section.scope.begin.texinfo"
			endCaptures:
				0: name: "punctuation.section.scope.end.texinfo"
			patterns: [
				name: "constant.character.texinfo"
				match: "[^\\s{}@,]+"
				
				{include: "#comma"}
				{include: "#main"}
			]
		}]


	# Inline code literal: `@verb{|…|}`
	verbatim:
		name:  "meta.command.braced.verb.texinfo"
		begin: "((@)verb)({)([^}])"
		end:   "(\\4)(})"
		contentName: "string.quoted.other.verbatim.texinfo"
		beginCaptures:
			1: name: "keyword.operator.command.verb.texinfo"
			2: name: "punctuation.definition.function.texinfo"
			3: name: "punctuation.section.scope.begin.texinfo"
			4: name: "punctuation.arbitrary.delimiter.begin.texinfo"
		endCaptures:
			1: name: "punctuation.arbitrary.delimiter.end.texinfo"
			0: name: "punctuation.section.scope.end.texinfo"
